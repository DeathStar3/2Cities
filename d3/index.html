<!--Inspired by https://bl.ocks.org/puzzler10/4438752bb93f45dc5ad5214efaa12e4a-->
<!DOCTYPE html>
<meta charset="utf-8">
<style>

    .links line {
        stroke: #999;
        stroke-opacity: 0.6;
    }

    .node text {
        stroke: #333;
        cursos: pointer;
    }
</style>
<svg width="800" height="500"></svg>
<script src="https://d3js.org/d3.v4.js"></script>
<script>


    var width = window.innerWidth,
        height = window.innerHeight - 10;

    var color = d3.scaleLinear()
        .range(["#FFFFFF", '#FF0000'])
        .interpolate(d3.interpolateRgb);

    //create somewhere to put the force directed graph
    var svg = d3.select("svg")
        .attr("width", width)
        .attr("height", height);

    d3.json("graph.json", function (json) {

        // json.links = json.links.filter(l => l.type != "INNER_CLASS");
        // json.nodes = json.nodes.filter(l => !l.type.includes("INNER_CLASS"));
        console.log(json.nodes);

        json.links = json.links.map(function (l) {
            var sourceNode = json.nodes.filter(function (n) {
                    return n.name === l.source;
                })[0],
                targetNode = json.nodes.filter(function (n) {
                    return n.name === l.target;
                })[0];
            return {source: sourceNode, target: targetNode};
        });

        var sort = json.nodes.filter(a => a.type.includes("CLASS")).map(a => parseInt(a.intensity)).sort((a, b) => a - b);
        color.domain([sort[0]-3, sort[sort.length - 1]]); // TODO deal with magic number

        //set up the simulation and add forces
        var simulation = d3.forceSimulation()
            .nodes(json.nodes);

        var link_force =  d3.forceLink(json.links)
            .id(function(d) { return d.name; }).distance(100);

        var charge_force = d3.forceManyBody().strength(-50);

        var center_force = d3.forceCenter(width / 2, height / 2);

        simulation
            .force("charge_force", charge_force)
            .force("center_force", center_force)
            .force("links",link_force);

        //add tick instructions:
        simulation.on("tick", tickActions );

        //add encompassing group for the zoom
        var g = svg.append("g")
            .attr("class", "everything");

        //draw lines for the links
        var link = g.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(json.links)
            .enter().append("line")
            .attr("stroke-width", 2)
            .style("stroke", "black");

        //draw circles for the nodes
        var node = g.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(json.nodes)
            .enter()
            .append("circle")
            .attr("stroke-width", 2)
            .style("stroke", function (d) {return d.type.includes("ABSTRACT") ? "black" : "none"})
            .attr("r", function (d) {return d.type.includes("CLASS") ? 10 + d.nodeSize : 10})
            .attr("fill", function (d) {return d.type.includes("CLASS") ? color(d.intensity) : "black"})
            .on("mouseover", function(d){ console.log(d.name) })
            .on("mouseout", function(d){ console.log(d.name) });

        var label = g.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(json.nodes)
            .enter()
            .append("text")
            .text(function (d) { return d.shortname; })
            .style("text-anchor", "middle")
            .style("fill", "#555")
            .style("font-family", "Arial")
            .style("font-size", 12);


        //add drag capabilities
        var drag_handler = d3.drag()
            .on("start", drag_start)
            .on("drag", drag_drag)
            .on("end", drag_end);

        drag_handler(node);


        //add zoom capabilities
        var zoom_handler = d3.zoom()
            .on("zoom", zoom_actions);

        zoom_handler(svg);

        /** Functions **/

        //Drag functions
        //d is the node
        function drag_start(d) {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        //make sure you can't drag the circle outside the box
        function drag_drag(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }

        function drag_end(d) {
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        //Zoom functions
        function zoom_actions(){
            g.attr("transform", d3.event.transform)
        }

        function tickActions() {
            //update circle positions each tick of the simulation
            node
                .attr("cx", function(d) { return d.x; })
                .attr("cy", function(d) { return d.y; });

            //update link positions
            link
                .attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

            label.attr("x", function(d){ return d.x; })
                .attr("y", function (d) {return d.y - 10; });
        }


    });


</script>
