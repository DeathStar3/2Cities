<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<style>
    /*	style definitions	*/
    button {
        position: absolute;
    }

    #blue {
        top: 1em;
        left: 1em;
    }

    #orange {
        top: 1em;
        left: 8em;
    }

    #green {
        top: 1em;
        left: 16em;
    }

    .node {
        stroke: white;
        stroke-width: 2px;
    }

    .link {
        stroke: gray;
        stroke-width: 4px;
    }

</style>
<button type="button" class="filter-btn" id="blue" value="CLASS">Filter classes</button>
<button type="button" class="filter-btn" id="orange" value="ABSTRACT">Filter abstract classes</button>
<button type="button" class="filter-btn" id="green" value="INTERFACE">Filter interfaces</button>
<svg width="960" height="500"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous"></script>
<script>

    //	data stores
    var graph, store;

    var width = window.innerWidth,
        height = window.innerHeight - 10;


    //	svg selection and sizing
    var svg = d3.select("svg").attr("width", width).attr("height", height);
    var radius = 10;

    //	d3 color scales
    var color = d3.scaleOrdinal(d3.schemeCategory10);

    var link = svg.append("g").selectAll(".link"),
        node = svg.append("g").selectAll(".node");

    //	force simulation initialization
    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink().distance(100)
            .id(function(d) { return d.name; }))
        .force("charge", d3.forceManyBody()
            .strength(function(d) { return -50;}))
        .force("center", d3.forceCenter(width / 2, height / 2));

    //	filtered types
    typeFilterList = [];

    //	filter button event handlers
    $(".filter-btn").on("click", function() {
        var id = $(this).attr("value");
        if (typeFilterList.includes(id)) {
            typeFilterList.splice(typeFilterList.indexOf(id), 1)
        } else {
            typeFilterList.push(id);
        }
        filter();
        update();
    });

    //	data read and store
    d3.json("graph.json", function(err, g) {
        if (err) throw err;

        var nodeByID = {};

        g.nodes.forEach(function(n) {
            nodeByID[n.name] = n;
        });

        g.links.forEach(function(l) {
            l.sourceTypes = nodeByID[l.source].type;
            l.targetTypes = nodeByID[l.target].type;
        });

        graph = g;
        store = $.extend(true, {}, g);

        update();
    });

    //	general update pattern for updating the graph
    function update() {
        //	UPDATE
        node = node.data(graph.nodes, function(d) { return d.name;});
        //	EXIT
        node.exit().remove();
        //	ENTER
        var newNode = node.enter().append("circle")
            .attr("class", "node")
            .attr("r", radius)
            .attr("fill", function(d) {return color(d.type[0]);})
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended)
            )

        newNode.append("title")
            .text(function(d) { return "group: " + d.type + "\n" + "name: " + d.name; });
        //	ENTER + UPDATE
        node = node.merge(newNode);

        //	UPDATE
        link = link.data(graph.links, function(d) { return d.name;});
        //	EXIT
        link.exit().remove();
        //	ENTER
        newLink = link.enter().append("line")
            .attr("class", "link");

        newLink.append("title")
            .text(function(d) { return "source: " + d.source + "\n" + "target: " + d.target; });
        //	ENTER + UPDATE
        link = link.merge(newLink);

        //	update simulation nodes, links, and alpha
        simulation
            .nodes(graph.nodes)
            .on("tick", ticked);

        simulation.force("link")
            .links(graph.links);

        simulation.alpha(1).alphaTarget(0).restart();
    }

    //	drag event handlers
    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    //	tick event handler with bounded box
    function ticked() {
        node
            .attr("cx", function(d) { return d.x = Math.max(radius, Math.min(width - radius, d.x)); })
            .attr("cy", function(d) { return d.y = Math.max(radius, Math.min(height - radius, d.y)); });

        link
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });
    }

    function isListElementInFilterList(li){
        return li.every(value => !typeFilterList.includes(value));
    }

    //	filter function
    function filter() {
        //	add and remove nodes from data based on type filters
        store.nodes.forEach(function(n) {
            if (isListElementInFilterList(n.type) && n.filtered) {
                n.filtered = false;
                graph.nodes.push($.extend(true, {}, n));
            } else if (isListElementInFilterList(n.type) && !n.filtered) {
                n.filtered = true;
                graph.nodes.forEach(function(d, i) {
                    if (n.name === d.name) {
                        graph.nodes.splice(i, 1);
                    }
                });
            }
        });

        //	add and remove links from data based on availability of nodes
        store.links.forEach(function(l) {
            if (!(isListElementInFilterList(l.sourceTypes) || isListElementInFilterList(l.targetTypes)) && l.filtered) {
                l.filtered = false;
                graph.links.push($.extend(true, {}, l));
            } else if ((isListElementInFilterList(l.sourceTypes) || isListElementInFilterList(l.targetTypes)) && !l.filtered) {
                l.filtered = true;
                graph.links.forEach(function(d, i) {
                    if (l.name === d.name) {
                        graph.links.splice(i, 1);
                    }
                });
            }
        });
    }

</script>